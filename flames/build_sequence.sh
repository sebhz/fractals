#!/bin/bash
set -ex

WORK_DIR="${WORK_DIR:-$(dirname $0)}"
TMP_DIR="${WORK_DIR}/tmp"
TMP_PFX=flame.
N_CTRL_PTS="${N_CTRL_PTS:-8}"
POINT_XML=points.flam3
SEQ_XML=sequence.flam3
FPS="${FPS:-25}" # FPS for video sequence
LOOP="${LOOP:-1}" # End the sequence with the start image.
RESTORE_FLAME="${RESTORE_FLAME:-0}" # Use a previous flame as starting point.
RESTORED_FLAME_FILE="${RESTORED_FLAME_FILE:-}" # Use a previous flame as starting point.
SEQUENCE_TIME_SEC="${SEQUENCE_TIME_SEC:-60}" # Length of the sequence

if [[ -e /usr/bin/nproc ]]; then
  nprocs="$(/usr/bin/nproc)"
else
  nprocs="$(cat /proc/cpuinfo 2>/dev/null | egrep '^processor' | wc -l)"
fi
N_THREADS="${N_THREADS:-$nprocs}"

PREFIX="${TMP_DIR}/${TMP_PFX}"

mkdir -p "${TMP_DIR}"
rm -f "${TMP_DIR}/*"

# Step 1: use flam3-genome to create N_CTRL_PTS control flames, stored in an XML file
env template="${WORK_DIR}/vidres.flam3" repeat="${N_CTRL_PTS}" flam3-genome > "${POINT_XML}"

# Step 2: if a looping sequence is required, replicate the first control flame at the last position
#         if the last frame of a previous sequence must be restored, insert it at first position, and
#         save the last frame of the current sequence for future use.
if [[ "$LOOP" == 1 ]]; then
  ${WORK_DIR}/process_flame.py -d "${POINT_XML}" > /tmp/new_points.xml
  if [[ $? != 0 ]]; then
    exit
  fi
  mv /tmp/new_points.xml "${POINT_XML}"
  N_CTRL_PTS="$((N_CTRL_PTS+1))"
elif [[ "${RESTORE_FLAME}" == 1 && -f "${RESTORED_FLAME_FILE}" ]]; then
  ${WORK_DIR}/process_flame.py -i "${POINT_XML}" "${RESTORED_FLAME_FILE}" > /tmp/new_points.xml
  if [[ $? == 0 ]]; then
    mv /tmp/new_points.xml "${POINT_XML}"
    N_CTRL_PTS="$((N_CTRL_PTS+1))"
  elif [[ $? == -1 ]]; then
    exit
  fi
fi

# Step 3: use flam3-genome again to create a sequence of flames from the previous XML
# (now containing N_CTRL_PTS or N_CTRL_PTS+1 control flames).
# The documentation seems incorrect: for a sequence description containing N control flames,
# the total number of frames generated by flam3-genome will be: (2*N-1)*nframes - 1.
# The rationale is:
# - nframes corresponding to the rotation of flame0
# - nframes corresponding to the transition between flame0 and flame1
#
# - nframes corresponding to the rotation of flame1
# - nframes corresponding to the transition between flame1 and flame2
#
# - nframes corresponding to the rotation of flameN-1
# - nframes corresponding to the transition between flameN-1 and flameN
#
# - nframes corresponding to the rotation of flameN
# - 1 last frame for flameN removed
#
# flam3-animate will eat the XML and generate the pictures from the flame description.
# So the formula relating number of frames between control points, sequence time and fps is:
# NFRAMES = (SEQUENCE_TIME_SEC*FPS+1)/(2*N_CTRL_PTS - 1)
NFRAMES=$(bc -l <<< "scale=0; (${SEQUENCE_TIME_SEC}*${FPS}+1)/(2*${N_CTRL_PTS}-1)")
TOTAL_FRAMES="$(( (2*${N_CTRL_PTS}-1)*${NFRAMES} - 1 ))"
ACTUAL_SEC=$(bc -l <<< "scale=2; ${TOTAL_FRAMES}/${FPS}")
echo "Will compute ${NFRAMES} frames per control points (${N_CTRL_PTS} control points: ${TOTAL_FRAMES} frames in total)."
echo "Actual sequence duration, with ${FPS} fps: ${ACTUAL_SEC} seconds."
env sequence="${POINT_XML}" nframes="${NFRAMES}" flam3-genome | tee "${SEQ_XML}" | env nthreads="${N_THREADS}" prefix="${PREFIX}" verbose=1 flam3-animate

# Step 4: generate a video from all the frames
ffmpeg -framerate "${FPS}" -i "${PREFIX}%05d.png" -pix_fmt yuv420p -crf 22 -vcodec libx264 "${PREFIX}mp4"
cp ${PREFIX}mp4 /tmp

# Step 5: if needed, save last frame for future use
if [[ "${RESTORE_FLAME}" == 1 ]]; then
  "${WORK_DIR}/process_flame.py" -x "${POINT_XML}" > "${RESTORED_FLAME_FILE}"
fi

